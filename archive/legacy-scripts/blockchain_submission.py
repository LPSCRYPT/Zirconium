#!/usr/bin/env python3
"""
Real Blockchain Submission for Weather Prediction
Submit verifiable weather prediction to Ethereum Sepolia testnet

REQUIREMENTS:
- Real EZKL proof (generated by weather_prediction.py)
- Sepolia testnet ETH
- Private key for transaction signing
"""

import json
import os
from web3 import Web3
from eth_account import Account
from typing import Dict, List, Tuple
from pathlib import Path

class BlockchainSubmitter:
    """Handle real blockchain submission of weather predictions"""
    
    def __init__(self):
        # Contract addresses from deployment
        self.contracts = {
            "ProductionxLSTMVerifier": "0x52a55dEBE04124376841dF391Ef0e4eF1dd6835B",
            "ProductionRWKVVerifier": "0x52b5e61fA6Ae53BA08B9094eA077820283Dcec01", 
            "ProductionMambaVerifier": "0x89dFdcC74Ed05bf2a76eF788b15e5cbC8Ad8C5cD"
        }
        
        # Sepolia testnet configuration
        self.chain_id = 11155111
        self.rpc_url = os.getenv('SEPOLIA_URL', 'https://rpc.sepolia.org')
        
        # Initialize Web3
        self.w3 = Web3(Web3.HTTPProvider(self.rpc_url))
        
        if not self.w3.is_connected():
            raise Exception("Failed to connect to Sepolia testnet")
        
        print(f"🔗 Connected to Ethereum Sepolia Testnet")
        print(f"   📡 RPC: {self.rpc_url}")
        print(f"   🆔 Chain ID: {self.chain_id}")
        print(f"   📊 Latest block: {self.w3.eth.block_number}")
        
        # Get private key from environment
        self.private_key = os.getenv('PRIVATE_KEY')
        if not self.private_key:
            raise Exception("PRIVATE_KEY environment variable required")
        
        # Create account
        self.account = Account.from_key(self.private_key)
        self.address = self.account.address
        
        # Check balance
        balance = self.w3.eth.get_balance(self.address)
        balance_eth = self.w3.from_wei(balance, 'ether')
        
        print(f"   👤 Address: {self.address}")
        print(f"   💰 Balance: {balance_eth:.6f} ETH")
        
        if balance_eth < 0.001:
            raise Exception(f"Insufficient ETH balance: {balance_eth:.6f}. Need at least 0.001 ETH")
        
        # Contract ABI (simplified for demonstration)
        self.verifier_abi = [
            {
                "inputs": [
                    {
                        "components": [
                            {"name": "a", "type": "uint256[2]"},
                            {"name": "b", "type": "uint256[2][2]"},
                            {"name": "c", "type": "uint256[2]"},
                            {"name": "z", "type": "uint256[2]"},
                            {"name": "t1", "type": "uint256[2]"},
                            {"name": "t2", "type": "uint256[2]"},
                            {"name": "t3", "type": "uint256[2]"},
                            {"name": "eval_a", "type": "uint256"},
                            {"name": "eval_b", "type": "uint256"},
                            {"name": "eval_c", "type": "uint256"},
                            {"name": "eval_s1", "type": "uint256"},
                            {"name": "eval_s2", "type": "uint256"},
                            {"name": "eval_zw", "type": "uint256"}
                        ],
                        "name": "proof",
                        "type": "tuple"
                    },
                    {"name": "publicInputs", "type": "uint256[]"}
                ],
                "name": "verifyProof",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            {"name": "a", "type": "uint256[2]"},
                            {"name": "b", "type": "uint256[2][2]"},
                            {"name": "c", "type": "uint256[2]"},
                            {"name": "z", "type": "uint256[2]"},
                            {"name": "t1", "type": "uint256[2]"},
                            {"name": "t2", "type": "uint256[2]"},
                            {"name": "t3", "type": "uint256[2]"},
                            {"name": "eval_a", "type": "uint256"},
                            {"name": "eval_b", "type": "uint256"},
                            {"name": "eval_c", "type": "uint256"},
                            {"name": "eval_s1", "type": "uint256"},
                            {"name": "eval_s2", "type": "uint256"},
                            {"name": "eval_zw", "type": "uint256"}
                        ],
                        "name": "proof",
                        "type": "tuple"
                    },
                    {"name": "publicInputs", "type": "uint256[]"},
                    {"name": "prompt", "type": "string"},
                    {"name": "continuation", "type": "string"}
                ],
                "name": "verifyModelInference",
                "outputs": [{"name": "inferenceId", "type": "bytes32"}],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ]
    
    def parse_ezkl_proof(self, proof_file: str) -> Tuple[Dict, List[int]]:
        """Parse real EZKL proof file into contract format"""
        
        print("\n🔧 Parsing Real EZKL Proof")
        print("-" * 30)
        
        if not os.path.exists(proof_file):
            raise Exception(f"Proof file not found: {proof_file}")
        
        with open(proof_file, 'r') as f:
            ezkl_proof = json.load(f)
        
        # Parse EZKL proof structure
        # Note: This needs to be updated based on actual EZKL 22.0.1 format
        proof_data = ezkl_proof.get("proof", {})
        
        # Extract proof components (format depends on EZKL version)
        proof_struct = {
            "a": [
                int(proof_data.get("a", ["0", "0"])[0], 16) if isinstance(proof_data.get("a", ["0", "0"])[0], str) else proof_data.get("a", [0, 0])[0],
                int(proof_data.get("a", ["0", "0"])[1], 16) if isinstance(proof_data.get("a", ["0", "0"])[1], str) else proof_data.get("a", [0, 0])[1]
            ],
            "b": [
                [
                    int(proof_data.get("b", [["0", "0"], ["0", "0"]])[0][0], 16) if isinstance(proof_data.get("b", [["0", "0"], ["0", "0"]])[0][0], str) else proof_data.get("b", [[0, 0], [0, 0]])[0][0],
                    int(proof_data.get("b", [["0", "0"], ["0", "0"]])[0][1], 16) if isinstance(proof_data.get("b", [["0", "0"], ["0", "0"]])[0][1], str) else proof_data.get("b", [[0, 0], [0, 0]])[0][1]
                ],
                [
                    int(proof_data.get("b", [["0", "0"], ["0", "0"]])[1][0], 16) if isinstance(proof_data.get("b", [["0", "0"], ["0", "0"]])[1][0], str) else proof_data.get("b", [[0, 0], [0, 0]])[1][0],
                    int(proof_data.get("b", [["0", "0"], ["0", "0"]])[1][1], 16) if isinstance(proof_data.get("b", [["0", "0"], ["0", "0"]])[1][1], str) else proof_data.get("b", [[0, 0], [0, 0]])[1][1]
                ]
            ],
            "c": [
                int(proof_data.get("c", ["0", "0"])[0], 16) if isinstance(proof_data.get("c", ["0", "0"])[0], str) else proof_data.get("c", [0, 0])[0],
                int(proof_data.get("c", ["0", "0"])[1], 16) if isinstance(proof_data.get("c", ["0", "0"])[1], str) else proof_data.get("c", [0, 0])[1]
            ],
            # Extract other EZKL proof components
            "z": [
                int(proof_data.get("z", ["0", "0"])[0], 16) if isinstance(proof_data.get("z", ["0", "0"])[0], str) else proof_data.get("z", [0, 0])[0],
                int(proof_data.get("z", ["0", "0"])[1], 16) if isinstance(proof_data.get("z", ["0", "0"])[1], str) else proof_data.get("z", [0, 0])[1]
            ],
            "t1": [
                int(proof_data.get("t1", ["0", "0"])[0], 16) if isinstance(proof_data.get("t1", ["0", "0"])[0], str) else proof_data.get("t1", [0, 0])[0],
                int(proof_data.get("t1", ["0", "0"])[1], 16) if isinstance(proof_data.get("t1", ["0", "0"])[1], str) else proof_data.get("t1", [0, 0])[1]
            ],
            "t2": [
                int(proof_data.get("t2", ["0", "0"])[0], 16) if isinstance(proof_data.get("t2", ["0", "0"])[0], str) else proof_data.get("t2", [0, 0])[0],
                int(proof_data.get("t2", ["0", "0"])[1], 16) if isinstance(proof_data.get("t2", ["0", "0"])[1], str) else proof_data.get("t2", [0, 0])[1]
            ],
            "t3": [
                int(proof_data.get("t3", ["0", "0"])[0], 16) if isinstance(proof_data.get("t3", ["0", "0"])[0], str) else proof_data.get("t3", [0, 0])[0],
                int(proof_data.get("t3", ["0", "0"])[1], 16) if isinstance(proof_data.get("t3", ["0", "0"])[1], str) else proof_data.get("t3", [0, 0])[1]
            ],
            "eval_a": int(proof_data.get("eval_a", "0"), 16) if isinstance(proof_data.get("eval_a", "0"), str) else proof_data.get("eval_a", 0),
            "eval_b": int(proof_data.get("eval_b", "0"), 16) if isinstance(proof_data.get("eval_b", "0"), str) else proof_data.get("eval_b", 0),
            "eval_c": int(proof_data.get("eval_c", "0"), 16) if isinstance(proof_data.get("eval_c", "0"), str) else proof_data.get("eval_c", 0),
            "eval_s1": int(proof_data.get("eval_s1", "0"), 16) if isinstance(proof_data.get("eval_s1", "0"), str) else proof_data.get("eval_s1", 0),
            "eval_s2": int(proof_data.get("eval_s2", "0"), 16) if isinstance(proof_data.get("eval_s2", "0"), str) else proof_data.get("eval_s2", 0),
            "eval_zw": int(proof_data.get("eval_zw", "0"), 16) if isinstance(proof_data.get("eval_zw", "0"), str) else proof_data.get("eval_zw", 0)
        }
        
        # Extract public inputs from EZKL proof
        public_inputs = ezkl_proof.get("instances", [])
        if not public_inputs:
            raise Exception("No public inputs found in EZKL proof")
        
        print(f"   📝 Parsed proof with {len(proof_struct)} components")
        print(f"   🔢 Public inputs: {public_inputs}")
        
        return proof_struct, public_inputs
    
    def submit_real_transaction(self, proof_struct: Dict, public_inputs: List[int], prediction: Dict) -> Dict:
        """Submit real blockchain transaction"""
        
        print("\n📤 Submitting Real Blockchain Transaction")
        print("-" * 40)
        
        contract_address = self.contracts["ProductionxLSTMVerifier"]
        contract = self.w3.eth.contract(
            address=contract_address,
            abi=self.verifier_abi
        )
        
        # Prepare transaction data
        prompt = f"Weather prediction for SF on {prediction['date']}"
        continuation = f"Temperature: {prediction['predicted_temp_f']}°F, Condition: {prediction['condition']}, Confidence: {prediction['confidence']:.1%}"
        
        print(f"   🎯 Contract: ProductionxLSTMVerifier")
        print(f"   📍 Address: {contract_address}")
        print(f"   🔧 Function: verifyModelInference()")
        print(f"   📝 Prompt: '{prompt}'")
        print(f"   📜 Continuation: '{continuation}'")
        
        # Build transaction
        transaction = contract.functions.verifyModelInference(
            proof_struct,
            public_inputs,
            prompt,
            continuation
        ).build_transaction({
            'from': self.address,
            'nonce': self.w3.eth.get_transaction_count(self.address),
            'gas': 200000,  # Estimated gas limit
            'gasPrice': self.w3.eth.gas_price,
            'chainId': self.chain_id
        })
        
        print(f"   ⛽ Gas limit: {transaction['gas']:,}")
        print(f"   💰 Gas price: {self.w3.from_wei(transaction['gasPrice'], 'gwei'):.2f} Gwei")
        
        # Sign and send transaction
        signed_txn = self.account.sign_transaction(transaction)
        
        print(f"   📤 Sending transaction...")
        tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
        
        print(f"   🆔 Transaction hash: {tx_hash.hex()}")
        print(f"   ⏳ Waiting for confirmation...")
        
        # Wait for confirmation
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
        
        if receipt.status == 1:
            print(f"   ✅ Transaction confirmed!")
            print(f"   📦 Block number: {receipt.blockNumber:,}")
            print(f"   ⛽ Gas used: {receipt.gasUsed:,}")
            
            # Extract inference ID from logs
            inference_id = None
            if receipt.logs:
                # Parse logs to get inference ID
                for log in receipt.logs:
                    if len(log.topics) > 0:
                        inference_id = log.topics[0].hex()
                        break
            
            return {
                "success": True,
                "transaction_hash": tx_hash.hex(),
                "block_number": receipt.blockNumber,
                "gas_used": receipt.gasUsed,
                "inference_id": inference_id,
                "etherscan_url": f"https://sepolia.etherscan.io/tx/{tx_hash.hex()}"
            }
        else:
            raise Exception(f"Transaction failed with status: {receipt.status}")

def submit_weather_prediction():
    """Main function to submit weather prediction to blockchain"""
    
    print("🚀 Real Weather Prediction Blockchain Submission")
    print("=" * 55)
    
    # Check for required environment variables
    if not os.getenv('PRIVATE_KEY'):
        print("❌ PRIVATE_KEY environment variable required")
        print("   Set with: export PRIVATE_KEY=your_private_key_here")
        return
    
    # Load prediction results
    results_file = "data/predictions/sf_weather_prediction_results.json"
    if not os.path.exists(results_file):
        print(f"❌ Results file not found: {results_file}")
        print("   Please run weather_prediction.py first")
        return
    
    with open(results_file, 'r') as f:
        prediction_results = json.load(f)
    
    print(f"📄 Loaded prediction: {prediction_results['prediction']['date']}")
    
    try:
        # Initialize blockchain submitter
        submitter = BlockchainSubmitter()
        
        # Parse EZKL proof
        proof_file = prediction_results["files_generated"]["proof"]
        proof_struct, public_inputs = submitter.parse_ezkl_proof(proof_file)
        
        # Submit real transaction
        transaction_result = submitter.submit_real_transaction(
            proof_struct, 
            public_inputs, 
            prediction_results["prediction"]
        )
        
        # Save final results
        final_results = {
            "prediction": prediction_results["prediction"],
            "model_output": prediction_results["model_output"],
            "blockchain_transaction": transaction_result,
            "summary": {
                "verifiable": True,
                "on_chain": True,
                "transaction_hash": transaction_result["transaction_hash"],
                "etherscan_url": transaction_result["etherscan_url"]
            }
        }
        
        final_file = "data/blockchain/verified_weather_prediction.json"
        os.makedirs(os.path.dirname(final_file), exist_ok=True)
        with open(final_file, 'w') as f:
            json.dump(final_results, f, indent=2, default=str)
        
        print(f"\n📄 Final results saved to: {final_file}")
        print(f"\n🎯 SUCCESS: Weather prediction verified on-chain!")
        print(f"   🔍 View on Etherscan: {transaction_result['etherscan_url']}")
        
        return final_results
        
    except Exception as e:
        print(f"\n❌ Submission failed: {e}")
        return None

if __name__ == "__main__":
    submit_weather_prediction()